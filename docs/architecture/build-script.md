# [Build script](/crates/common/build.rs)

This is the "handshake" of your project. Since your macOS client and Windows/Linux host are essentially strangers, Protobuf acts as the universal translator that ensures they both understand the structure of the data being sent over the wire.

---

## 1. Protobuf Breakdown (`compute.proto`)

```protobuf
syntax = "proto3";          // Defines the version of the protocol buffers language.
package compute;            // Namespaces the generated code to avoid naming collisions.

// The "Service" is like an Interface or a Trait.
// It defines the methods that the Server (Host) must implement.
service CUDAExecutor {
    // rpc stands for "Remote Procedure Call".
    // 'stream' indicates that the Host won't just send one reply;
    // it will keep the connection open and push multiple updates (logs) 
    // until the GPU task is finished.
    rpc ExecuteCode (ComputeRequest) returns (stream ComputeResponse);
}

// Data sent from the macOS Client to the Server.
message ComputeRequest {
    string source_code = 1;         // The actual content of the .cu file.
    string file_name = 2;           // Helps the host name the temporary file (e.g., "kernel.cu").
    repeated string compiler_flags = 3; // 'repeated' is Protobuf's way of saying "a Vec or List".
}

// Data streamed back from the Host to the Client.
message ComputeResponse {
    string output = 1;  // Could be a line of compiler output, or the final GPU result.
    bool is_error = 2;  // A flag to let the client know if this specific line is an error/stderr.
}

```

### Why use `stream`?

If you didn't use a stream, the client would send the code and then sit in silence for 10 seconds while the server compiles and runs it. With a **stream**, as soon as `nvcc` prints its first line of output, the Host can push that line to the Client immediately. This makes the CLI feel much more responsive.

---

## 2. The Build Script (`crates/common/build.rs`)

In Rust, a `build.rs` file is executed **before** your crate is compiled. We use it here to tell `tonic-build` to take your `.proto` file and turn it into valid Rust structs and traits.

Create this file at `crates/common/build.rs`:

```rust
fn main() -> Result<(), Box<dyn std::error::Error>> {
    // This compiles the .proto file into Rust code.
    // By default, the generated code is placed in the 'OUT_DIR' 
    // (inside the /target folder), keeping your src/ directory clean.
    tonic_build::compile_protos("proto/compute.proto")?;
    Ok(())
}

```

### How it works:

1. When you run `cargo build`, Cargo detects `build.rs`.
2. `tonic-build` reads your `compute.proto`.
3. It generates a file (usually named `compute.rs`) containing a `ComputeRequest` struct and a `CudaExecutorClient` / `CudaExecutorServer` trait.
4. These are hidden in your `/target` folder but can be easily included in your `src/lib.rs`.

---

## 3. Sample Usage & Implementation

To make this generated code accessible to your `client` and `host` crates, you need to "expose" it in your `common` library.

### `crates/common/src/lib.rs`

```rust
// This macro pulls in the code generated by the build script.
pub mod compute {
    tonic::include_proto!("compute"); 
}

```

## Ferris-Compute-Cuda Implementation Guide

### Adding Dependencies to `common`

Ensure your `crates/common/Cargo.toml` looks like this:

```toml
[package]
name = "common"
version.workspace = true
edition.workspace = true

[dependencies]
tonic = "0.12"
prost = "0.13"
tokio = { version = "1", features = ["full"] }

[build-dependencies]
tonic-build = "0.12"

```

### How the Client uses it

In `crates/client/src/main.rs`, you would connect like this:

```rust
use common::compute::cuda_executor_client::CudaExecutorClient;
use common::compute::ComputeRequest;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Connect to the Windows/Linux host
    let mut client = CudaExecutorClient::connect("http://[YOUR_SERVER_IP]:50051").await?;

    let request = tonic::Request::new(ComputeRequest {
        source_code: " __global__ void hello() { ... } ".into(),
        file_name: "kernel.cu".into(),
        compiler_flags: vec!["-arch=sm_75".into()],
    });

    let mut stream = client.execute_code(request).await?.into_inner();

    while let Some(response) = stream.message().await? {
        println!("Server says: {}", response.output);
    }

    Ok(())
}
